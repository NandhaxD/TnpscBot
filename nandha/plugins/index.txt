

import time
import json
import config
import asyncio
import re

from pyrogram import filters, types, enums
from nandha import bot, LOG, font
from nandha.db.autofilter import add_file
from nandha.utils import fixed_file_name, get_size, generate_random_string
from nandha.helpers.decorator import only_devs

__module__ = 'indexing'

__help__ = '''

- /afindex (start int) ([file_naame]) (end int) (chat username/id):

file_name is custom don't use it else it will be set to all indexing files.

<b>Example Usage:</b>
<code>
/afindex
start 10
end 50
chat @nandhabots
</code>
'''

index_data = {}
indexing = []

ALLOWED_MIME_TYPES = [
    'application/x-subrip',
    'application/vnd.android.package-archive',
    'video/x-msvideo',
    'video/mp4',
    'video/x-matroska',
    'audio/mp3', 'audio/mp4',
    'audio/mpeg'
]

async def start_indexing(user_id: int, chat_id: int, last_msg_id: int, start_index: int, file_name: str, m, token):
    current_id = start_index
    empty = 0
    no_name = 0
    duplicate = 0
    not_sup = 0
    added = []
    failed = []

    def create_status_text(status="‚öôÔ∏è Processing..."):
        return f"""
*üìä Channel Indexing Status*
‚îî Channel ID: `{chat_id}`

*üìà Progress Details:*
‚îú ‚úÖ Added Files: `{len(added)}`
‚îú üì≠ Empty Files: `{empty}`
‚îú üí≠ No Name Files: `{no_name}`
‚îú ‚ÄºÔ∏è Not Supported: `{not_sup}`
‚îú üìë Duplicate Files: `{duplicate}`
‚îî ‚ùå Failed Files: `{len(failed)}`

*‚ö° Progress:* `{current_id}/{last_msg_id}`
*üïí Status:* `{status}`
"""

    def create_markup(include_results=False):
        rows = [
            [types.InlineKeyboardButton(font('‚õî Cancel Index'), callback_data=f"afindex_cancel#{user_id}#{token}")]
        ]
        if include_results:
            rows[0].append(
                types.InlineKeyboardButton(font('üì© Result'), callback_data=f"afindex_results#{user_id}#{token}"))
        rows.append([
            types.InlineKeyboardButton(font('‚ùå Close'), callback_data=f"delete#{m.chat.id if m.chat.type.value.lower() == 'private' else m.from_user.id}")])
        return types.InlineKeyboardMarkup(rows)

    try:
        status_message = await m.edit_text(
            create_status_text(),
            reply_markup=create_markup(),
        )

        last_update_time = time.time()
        update_interval = 10

        while current_id < last_msg_id:
            batch_end = min(current_id + 300, last_msg_id)
            message_ids = list(range(current_id, batch_end))

            try:
                msgs = await bot.get_messages(chat_id, message_ids=message_ids)
                await asyncio.sleep(4) 

                for idx, msg in enumerate(msgs, start=current_id):  
                    current_id = idx + 1

                    current_time = time.time()
                    if current_time - last_update_time >= update_interval:
                        try:
                            await status_message.edit_text(
                                create_status_text(),
                                reply_markup=create_markup()
                            )
                            last_update_time = current_time
                        except Exception as edit_error:
                            LOG.error(f"Failed to update status: {str(edit_error)}")

                    if not msg or not msg.media or msg.empty:
                        empty += 1
                        continue

                    media_types = {
                        'video': (msg.video, 'video'),
                        'document': (msg.document, 'document'),
                        'audio': (msg.audio, 'audio')
                    }

                    media_obj = None
                    file_type = None

                    for obj, type_name in media_types.values():
                        if obj:
                            media_obj = obj
                            file_type = type_name
                            break

                    if not media_obj:
                        empty += 1
                        continue

                    try:
                        file_id = media_obj.file_id
                        original_file_name = media_obj.file_name if file_type != 'audio' else f"{getattr(media_obj, 'file_name', '')} - {getattr(msg.audio, 'title', 'songs')}"
                        file_size = media_obj.file_size
                        mime_type = getattr(media_obj, 'mime_type', None)

                        if mime_type and mime_type not in ALLOWED_MIME_TYPES:
                            not_sup += 1
                            continue #skip
                        elif msg.audio and not getattr(msg.audio,'title', None):
                            not_sup += 1
                            continue #skip

                        file_unique_id = media_obj.file_unique_id

                        if not original_file_name:
                            no_name += 1
                            continue #skip

                        file_size = get_size(file_size)
                        name = fixed_file_name(original_file_name, file_type, file_size)
                        
                        final_file_name = file_name if file_name else name

                        try:
                            file = await add_file(
                                final_file_name,
                                file_id,
                                file_unique_id,
                                file_type
                            ) 
                            if file:
                                added.append(file_id)
                            else:
                                duplicate += 1
                        except Exception as add_error:
                            LOG.error(f"Error adding file to database: {str(add_error)}")
                            failed.append(file_id)

                    except Exception as e:
                        LOG.error(f"Error processing file {file_id}: {str(e)}")
                        failed.append(file_id)

            except Exception as batch_error:
                LOG.error(f"Error processing batch {current_id}-{batch_end}: {str(batch_error)}")

            if current_id < batch_end:
                current_id = batch_end

    except asyncio.CancelledError:
        await status_message.edit_text(
            create_status_text("‚ö´ Cancelled"),
            reply_markup=create_markup(True),
        )
        raise
    except Exception as e:
        LOG.error(f"Fatal error in indexing: {str(e)}")
        await status_message.edit_text(
            create_status_text("‚ùå Failed"),
            reply_markup=create_markup(True),
        )
    else:
        await status_message.edit_text(
            create_status_text("‚úÖ Completed"),
            reply_markup=create_markup(True),
        )
    finally:
        data = {
            'added_count': len(added),
            'no_name_count': no_name,
            'failed_count': len(failed),
            'failed_ids': failed,
            'not_sup_count': not_sup,
            'empty_count': empty,
            'duplicate_count': duplicate
        }
        return data



@bot.on_callback_query(filters.regex('^afindex'))
async def _cq_indexer(update, context):
    m = update.effective_message
    query = update.callback_query
    cmd, user_id, token = query.data.split("#")

    if query.from_user.id != int(user_id):
        return await query.answer('This Command Not Request By You!', show_alert=True)

    data = index_data.get(token)
    if not data:
        return await m.edit_text('ü§∑ <b>This Indexer was expired!</b>')

    chat_id, message_id, start_index, file_name = data

    try:
        if cmd == "afindex_start":
            if indexing:
                await m.edit_text("<b>Already one indexing process is running.</b>")
            else:
                task = asyncio.create_task(start_indexing(int(user_id), chat_id, message_id, start_index, file_name, m, token))
                indexing.append(task)
                await query.answer("Indexing started!", show_alert=True)

        elif cmd == "afindex_cancel":
            if indexing:
                indexing[0].cancel()
                indexing.clear()
                await query.answer("Indexing cancelled!", show_alert=True)
            else:
                await m.edit_text("<b>No indexing task is running!</b>")

        elif cmd == "afindex_results":
            if not indexing:
                return await m.edit_text("<b>No indexing process is running...</b>")

            try:
                data = await indexing[0]
                path = 'indexer.json'
                with open(path, 'w+') as file:
                    json.dump(data, file, indent=4)
                await m.reply_document(path)
                await query.answer("Results generated!", show_alert=True)
            except Exception as e:
                LOG.error(f"Error generating results: {str(e)}")
                await query.answer("Error generating results!", show_alert=True)

    except Exception as e:
        LOG.error(f"Callback error: {str(e)}")
        await query.answer("An error occurred!", show_alert=True)



@bot.on_message(filters.command('afindex'))
@only_devs
async def _indexer(update, context):
    m = update.effective_message
    r = m.reply_to_message
    user = m.from_user
    text = m.text

    message_id = None
    file_name = None
    start_index = 0

    try:
        names_pattern = re.compile(r'\[(.*?)\]', flags=re.IGNORECASE)
        names_match = names_pattern.search(text)
        if names_match:
            file_name = names_match.group(1).strip()

        end_pattern = re.compile(r'end\s(\d+)', flags=re.IGNORECASE)
        end_index_match = end_pattern.search(text)
        if end_index_match:
            message_id = int(end_index_match.group(1))

        sidx_pattern = re.compile(r'\s+start\s(\d+)', re.IGNORECASE)
        start_index_match = sidx_pattern.search(m.text)
        if start_index_match:
            start_index = int(start_index_match.group(1))

        chat_filter = re.compile(r'chat\s(.*)', flags=re.IGNORECASE)
        is_chat = chat_filter.search(text)

        if r and r.forward_origin and r.forward_origin.chat.type == enums.ChatType.CHANNEL:
            chat_id = r.forward_origin.chat.id
            message_id = r.forward_origin.message_id
        elif is_chat:
            chat_id = int(is_chat.group(1)) if is_chat.group(1).isdigit() else is_chat.group(1)
        else:
            return await m.reply_text("Give me chat id or reply to forwarded msg id from channel!")

        if not message_id:
            return await m.reply_text("index Ends Message id not Found!")

        token = generate_random_string(6)
        index_data[token] = [
            chat_id, message_id + 1, start_index, file_name
        ]

        if not indexing:
            buttons = types.InlineKeyboardMarkup([[
                types.InlineKeyboardButton(font('‚ú® Start Index'), callback_data=f"afindex_start#{user.id}#{token}"),
                types.InlineKeyboardButton(font('‚ùå Close'), callback_data=f"delete#{user.id}")
            ]])
            await m.reply_text(
                "üîç *Ready to Index*\n\n"
                "Press the button below to begin indexing files.\n"
                f"File Name: `{file_name}`\n"
                f"Start Index: `{start_index}`",
                reply_markup=buttons,
            )
        else:
            buttons = types.InlineKeyboardMarkup([[
                types.InlineKeyboardButton(font('‚õî Cancel Index'), callback_data=f"afindex_cancel#{user.id}#{token}"),
                types.InlineKeyboardButton(font('‚ùå Close'), callback_data=f"delete#{user.id}")
            ]])
            await m.reply_text(
                "‚ö†Ô∏è *Indexing in Progress*\n\n"
                "Another indexing process is currently running.\n"
                "Please cancel it before starting a new one.",
                reply_markup=buttons,
            )
    except Exception as e:
        LOG.error(f"Command error: {str(e)}")
        await m.reply_text(
            "‚ùå *Error Occurred*\n\n"
            "Failed to process your request.\n"
            "Please try again or contact admin.",
        )
